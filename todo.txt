# TODO
see data num of implemented lastly

use clear_grads()

* training online(DONE), measure time of training so that determine loop_num
* plot online of loss, when training online
* predict some steps when realtime mpc

* make video of real robot with rviz

* in publish_diabolo_model.cpp, subscribe arm EE to visualize string
* subscribe input in diabolo_system realtime feedback with simulation



consider optimization of controller
  modify loss func
    x loss(pitch_diff, yaw_diff) = pitch_diff + yaw_diff
    o loss(pitch_diff, yaw_diff) = w1 * pitch_diff + w2 * yaw_diff

let hrp2 juggle


refactor
  whether everything work well after refactoring
what is latch

calc pitch more acculately
  not use one point, use some points when calculating pitch. at least 3 points each
  




consider model
  x(t) = f(x(t-1), x(t-2), u(t-1)
  dx(t)/dt = f(x(t-1), x(t-2), u(t-1)  <- this is better?
  the way not to overfit

add physical parameters
  train
  estimation

# DONE
apply LPF
  record stable diabolo pitch and yaw
  calc frequency
  (calc covariance)
  calc w0 or average_num of LPF
  apply LPF to log data
  plot and see whether LPF work well

fit
  see accuracy
  
predict
  see accuracy

simulate by forwaring of NeurlNetwork
  make diabolo of eus model
  translate to COLLADA
  diaplay in RViz
  move robot with euslisp

plot weight (in_neruron + 1) * mid_neuron + (mid_neuron + 1) * out_neuron
