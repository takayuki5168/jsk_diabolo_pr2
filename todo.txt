# TODO
use clear_grads()

* is it ok to while spinOnce(acutually not use spinOnce), not spin in diabolo_system
    when spin is called

* test whether online training work well

* predict some steps when realtime mpc

* subscribe input in diabolo_system realtime feedback with simulation



consider optimization of controller
  modify loss func
    x loss(pitch_diff, yaw_diff) = pitch_diff + yaw_diff
    o loss(pitch_diff, yaw_diff) = w1 * pitch_diff + w2 * yaw_diff




refactor
  whether everything work well after refactoring
what is latch

calc pitch more acculately
  not use one point, use some points when calculating pitch. at least 3 points each
  




consider model
  x(t) = f(x(t-1), x(t-2), u(t-1)
  dx(t)/dt = f(x(t-1), x(t-2), u(t-1)  <- this is better?
  the way not to overfit

add physical parameters
  train
  estimation

# DONE
apply LPF
  record stable diabolo pitch and yaw
  calc frequency
  (calc covariance)
  calc w0 or average_num of LPF
  apply LPF to log data
  plot and see whether LPF work well

fit
  see accuracy
  
predict
  see accuracy

simulate by forwaring of NeurlNetwork
  make diabolo of eus model
  translate to COLLADA
  diaplay in RViz
  move robot with euslisp

plot weight (in_neruron + 1) * mid_neuron + (mid_neuron + 1) * out_neuron

training online

plot online of loss, when training online

make video of real robot with rviz

let hrp2 juggle

in publish_diabolo_model.cpp, subscribe arm EE to visualize string
